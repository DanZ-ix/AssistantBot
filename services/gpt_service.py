from datetime import datetime

from loader import yandex_gpt

system_get_meta_prompt = '''
Ты — помощник для анализа запросов пользователя на естественном языке. Твоя задача — определить, что хочет пользователь, и вернуть результат в формате массива JSON.
Пользователь в одном сообщении может сделать несколько запросов, в таком случае нужно вернуть несколько элементов массива
Возможные действия:
1. **Сохранить заметку**:
   - Пользователь хочет сохранить текст в заметки.
   - Добавь в результирующий массив объект в формате ниже, удаляя из текста команду сохранения заметки, оставить только суть:
     {
       "action": "save_note",
       "result": "текст заметки"
     }
2. **Общий запрос к LLM**:
   - Пользователь делает запрос в общем виде.
   - Добавь в результирующий массив объект в формате ниже, в поле response напиши запрос пользователя, переформулированный в промт к LLM:
     {
       "action": "general_question",
       "result": "Запрос пользователя"
     }
3. **Запись продуктов в список покупок**:
   - Пользователь просит записать продукты в список покупок
   - Добавь в результирующий массив объект в формате ниже:
     {
       "action": "add_good_to_list",
       "result": {JSON объект с запросом к mongodb для вставки всех товаров в формате [{"good": "товар"}]}  
     } 
4. **Получение списка продуктов**:
   - Пользователь просит вывести список покупок
   - Добавь в результирующий массив объект в формате ниже:
     {
       "action": "get_buy_list",
       "result": null
     }
5. **Удаление продуктов из списка покупок**:
   - Пользователь просит удалить продукты из списка продуктов
   - Добавь в результирующий массив объект в формате ниже:
     {
       "action": "delete_goods",
       "result": {JSON объект с запросом к mongodb для удаления записей в формате [{"good": "товар"}]}  
     } 
6. **Создание напоминания**:
   - Пользователь просит создать напоминание на какое то время
   - Добавь в результирующий массив объект в формате ниже:
     {
       "action": "add_reminder",
       "result": {"notify_text": "Текст напоминания со временем"} 
     }           
'''


system_create_reminder_query = '''
Ты — помощник для обработки напоминаний. Твоя задача — извлекать из текста напоминание и дату/время, преобразуя их в формат JSON.

Инструкция:
1. Извлеки текст напоминания, исключив из него все упоминания даты и времени. Дополни текст напоминания контекстом, чтобы напоминание было понятнее
2. Определи абсолютную дату и время напоминания, используя текущие дату и время: {{current_datetime}}.
3. Если указан только день, время не указано, то считай время равным 12 часам дня
4. Верни результат в формате JSON:
   {"reminder_text": "текст напоминания без даты/времени", "reminder_datetime": "ISO-формат"}

Примеры:
Вход: "Напомни купить хлеб завтра в 8 утра"
Выход: {"reminder_text": "Необходимо купить хлеб", "reminder_datetime": "2023-10-26T08:00:00"}

Вход: "Встреча на следующей неделе во вторник"
Выход: {"reminder_text": "Напоминание о встрече", "reminder_datetime": "2023-10-31T12:00:00"}

Вход: "Через 3 дня в 15:00 сдать отчет"
Выход: {"reminder_text": "Необходимо сдать отчет", "reminder_datetime": "2023-10-28T15:00:00"}

Вход: "15 ноября в 18:00 концерт"
Выход: {"reminder_text": "Напоминание о концерте", "reminder_datetime": "2023-11-15T18:00:00"}

Особенности:
- Если дата/время не распознаны, верни {"error": "Не удалось распознать дату/время"}
- Если текст напоминания пуст, верни {"error": "Текст напоминания не указан"}
- Для относительных дат («завтра», «через час») вычисляй относительно {{current_datetime}}
- Для дней недели («в понедельник») выбирай ближайшую будущую дату
'''


system_get_delete_good_query = '''
Ты — помощник по обработке данных. Твоя задача — проанализировать входные данные и вернуть массив ObjectId для удаления. 

Входные данные:
1. "Весь список" — массив объектов, где каждый объект содержит ключи "_id" (тип ObjectId) и "good" (строка).
2. "Необходимо удалить" — массив объектов, где каждый объект содержит ключ "good" (строка). Эти строки указывают, какие элементы из "Всего списка" нужно удалить.

Правила обработки:
- Сравнивай значения ключа "good" из "Необходимо удалить" с соответствующими значениями из "Всего списка". Сравнение должно быть регистронезависимым.
- Если значение из "Необходимо удалить" является частью значения из "Всего списка" (или наоборот), считай это совпадением. Например, "чипсеки" и "чипсы" считаются совпадающими.
- Для каждого совпадения добавляй ObjectId из "Всего списка" в результирующий массив.
- Если в "Необходимо удалить" есть элементы, которые отсутствуют в "Всем списке", игнорируй их.

Выходные данные:
- Массив ObjectId, которые нужно удалить.

Пример входных данных:
ObjectId('67d334c7a0fc1d5ed427c5d0'), ObjectId('67d334c7a0fc1d5ed427c5d2')]
'''

async def get_task_meta(text):
    query = [
        {
            "role": "system",
            "text": system_get_meta_prompt
        },
        {
            "role": "user",
            "text": text
        }
    ]

    gpt_result = await send_query(query)
    print(gpt_result)

    return gpt_result.strip("```")


async def get_delete_good_ids(good_list_str: str, delete_list_str: str):
    query = [
        {
            "role": "system",
            "text": system_get_delete_good_query
        },
        {
            "role": "user",
            "text": f"Весь список: {good_list_str}\nНеобходимо удалить: {delete_list_str}"
        }
    ]
    gpt_result = await send_query(query)
    return gpt_result.strip("```")


async def create_reminder_meta(reminder_text):
    current_datetime_str = datetime.now().strftime("%d.%m.%Y %H:%M:%S %A")
    system_prompt = system_create_reminder_query.replace("{{current_datetime}}", current_datetime_str)
    query = [
        {
            "role": "system",
            "text": system_prompt
        },
        {
            "role": "user",
            "text": f"{reminder_text}"
        }
    ]
    gpt_result = await send_query(query)
    print(gpt_result)
    return gpt_result.strip("```")


async def send_query(query):
    result = await yandex_gpt.run(query)
    return result[0].text
